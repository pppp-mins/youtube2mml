"""
MML Generator Module
Generate MML code from analyzed music tracks
"""

from typing import List, Tuple

from .models import Track


class MMLGenerator:
    """Generate MML code from analyzed music tracks"""

    def __init__(self, compact: bool = True):
        """
        Initialize MML generator

        Args:
            compact: If True, generate compact MML without spaces (default: True)
        """
        self.note_names = ['C', 'C+', 'D', 'D+', 'E', 'F', 'F+', 'G', 'G+', 'A', 'A+', 'B']
        self.compact = compact

    def generate(self, tracks: List[Track], title: str = "Untitled") -> str:
        """
        Generate complete MML code

        Args:
            tracks: List of Track objects (melody, harmony1, harmony2)
            title: Song title

        Returns:
            MML code string

        Raises:
            ValueError: If melody track is not found
        """
        # Find melody track
        melody = next((t for t in tracks if t.name == "melody"), None)
        harmonies = [t for t in tracks if t.name.startswith("harmony")]

        if not melody:
            raise ValueError("Melody track not found")

        # Use melody's tempo and time signature
        tempo = melody.tempo
        time_sig = melody.time_signature
        key = melody.key_signature

        # Generate MML header
        mml = self._generate_header(title, tempo, time_sig, key)

        # Generate melody track
        mml += "\n// Melody Track\n"
        mml += "MML@"
        mml += self._generate_track_mml(melody)
        mml += ";\n"

        # Generate harmony tracks
        for i, harmony in enumerate(harmonies[:2], 1):  # Limit to 2 harmonies
            mml += f"\n// Harmony {i} Track\n"
            mml += f"MML@"
            mml += self._generate_track_mml(harmony)
            mml += ";\n"

        return mml

    def _generate_header(self, title: str, tempo: int,
                        time_sig: Tuple[int, int], key: str) -> str:
        """
        Generate MML header with metadata

        Args:
            title: Song title
            tempo: Tempo in BPM
            time_sig: Time signature tuple (numerator, denominator)
            key: Key signature

        Returns:
            MML header string
        """
        header = f"// {title}\n"
        header += f"// Tempo: {tempo} BPM\n"
        header += f"// Time Signature: {time_sig[0]}/{time_sig[1]}\n"
        header += f"// Key: {key}\n"
        header += "// Generated by YouTube2MML\n"
        return header

    def _generate_track_mml(self, track: Track) -> str:
        """
        Generate MML code for a single track

        Args:
            track: Track object

        Returns:
            MML code string (without track label)
        """
        if not track.notes:
            return "r1;"  # Whole rest if no notes

        separator = "" if self.compact else " "
        mml = f"t{track.tempo}{separator}"  # Set tempo

        current_octave = 4
        last_time = 0.0

        for note in track.notes:
            # Add rest if there's a gap
            gap = note.start_time - last_time
            if gap > 0.01:  # Threshold for rest
                rest_mml = self._duration_to_mml(gap, track.tempo)
                mml += f"r{rest_mml}{separator}"

            # Convert note
            note_name, octave = self._midi_to_note(note.pitch)

            # Change octave if needed
            if octave != current_octave:
                mml += f"o{octave}{separator}"
                current_octave = octave

            # Add note with duration
            duration_mml = self._duration_to_mml(note.duration, track.tempo)
            mml += f"{note_name}{duration_mml}{separator}"

            last_time = note.start_time + note.duration

        return mml.strip()

    def _midi_to_note(self, midi_pitch: int) -> Tuple[str, int]:
        """
        Convert MIDI pitch to note name and octave

        Args:
            midi_pitch: MIDI note number (0-127)

        Returns:
            Tuple of (note_name, octave)
        """
        octave = (midi_pitch // 12) - 1
        note_index = midi_pitch % 12
        note_name = self.note_names[note_index]
        return note_name, octave

    def _duration_to_mml(self, duration: float, tempo: int) -> str:
        """
        Convert duration in seconds to MML length notation

        Args:
            duration: Duration in seconds
            tempo: Tempo in BPM

        Returns:
            MML length string (e.g., "4", "8", "16", "4.")
        """
        # Calculate duration in beats
        beat_duration = 60.0 / tempo
        beats = duration / beat_duration

        # Map to MML lengths
        # 1 = whole note (4 beats)
        # 2 = half note (2 beats)
        # 4 = quarter note (1 beat)
        # 8 = eighth note (0.5 beat)
        # 16 = sixteenth note (0.25 beat)
        # Add "." for dotted notes (1.5x duration)

        if abs(beats - 4.0) < 0.1:
            return "1"  # Whole note
        elif abs(beats - 2.0) < 0.1:
            return "2"  # Half note
        elif abs(beats - 1.5) < 0.1:
            return "4."  # Dotted quarter
        elif abs(beats - 1.0) < 0.1:
            return "4"  # Quarter note
        elif abs(beats - 0.75) < 0.1:
            return "8."  # Dotted eighth
        elif abs(beats - 0.5) < 0.1:
            return "8"  # Eighth note
        elif abs(beats - 0.25) < 0.1:
            return "16"  # Sixteenth note
        else:
            # Default to closest standard length
            if beats >= 1.5:
                return "2"
            elif beats >= 0.75:
                return "4"
            elif beats >= 0.375:
                return "8"
            else:
                return "16"


def main():
    """Example usage of MMLGenerator"""
    from .models import Note, Track

    # Create sample tracks
    melody_notes = [
        Note(pitch=60, start_time=0.0, duration=0.5, velocity=80, confidence=0.9),  # C4
        Note(pitch=64, start_time=0.5, duration=0.5, velocity=75, confidence=0.85),  # E4
        Note(pitch=67, start_time=1.0, duration=0.5, velocity=70, confidence=0.8),   # G4
        Note(pitch=72, start_time=1.5, duration=0.5, velocity=85, confidence=0.95),  # C5
    ]
    melody = Track(name="melody", notes=melody_notes, tempo=120, time_signature=(4, 4), key_signature="C")

    harmony1_notes = [
        Note(pitch=48, start_time=0.0, duration=1.0, velocity=60, confidence=0.8),  # C3
        Note(pitch=52, start_time=1.0, duration=1.0, velocity=60, confidence=0.8),  # E3
    ]
    harmony1 = Track(name="harmony1", notes=harmony1_notes, tempo=120, time_signature=(4, 4), key_signature="C")

    # Generate MML
    generator = MMLGenerator()
    mml_code = generator.generate([melody, harmony1], "Test Song")

    print("Generated MML Code:")
    print("=" * 60)
    print(mml_code)
    print("=" * 60)


if __name__ == "__main__":
    main()
